Here is the Developer-Level Specification for the **Enoki Bridge SPA**.

## 1. System Overview
The **Bridge SPA** is a lightweight, stateless web application hosted on a public HTTPS origin. Its primary responsibility is to act as a secure proxy for the OAuth/OpenID Connect (OIDC) flow, which cannot be securely performed directly within the Obsidian (Electron) `app://` protocol.

**Core Responsibilities:**
1.  **Ingest:** Detect login requests initiated by the Obsidian Plugin.
2.  **Authenticate:** Orchestrate the OIDC flow via the Enoki SDK/Client.
3.  **Hydrate:** Retrieve the specific zkLogin data (Salt + Address) required by the desktop client.
4.  **Eject:** Deep-link back to the local desktop environment with the session payload.

---

## 2. Data Models & Schemas

### 2.1. Input Schema (Obsidian $\to$ Bridge)
Passed via URL Query Parameters when opening the SPA.

| Parameter | Type | Required | Description |
| :--- | :--- | :--- | :--- |
| `source` | string | **Yes** | Must be set to `obsidian`. Signals the SPA to enter "Bridge Mode" rather than "Standalone Mode". |
| `provider` | string | No | The preferred auth provider (e.g., `google`, `twitch`). Defaults to `google` if omitted. |
| `redirect` | boolean| No | If `true`, the SPA attempts to auto-redirect to the provider immediately without user interaction (optional UX optimization). |
| `nonce` | string | **Yes** | The nonce (hash of ephemeral public key) generated by Obsidian. Required for transaction signing. |

**Example URL:**
`https://bridge-app.com/?source=obsidian&provider=google&nonce=12345...`

### 2.2. Output Schema (Bridge $\to$ Obsidian)
Passed via the custom protocol payload (`obsidian://enoki-auth?...`).

| Parameter | Type | Format | Description |
| :--- | :--- | :--- | :--- |
| `jwt` | string | JWT (Base64) | The raw OIDC ID Token received from the identity provider. |
| `salt` | string | Hex/BigInt String | The user-specific salt retrieved from the Enoki service. **Critical** for address derivation. |
| `address` | string | 0xString | The derived Sui Address (zkLogin address) for this user. |
| `epoch` | number | integer | (Optional) The current Sui epoch used for the proof (if strict epoch validity is required). |

**Example URI:**
`obsidian://enoki-auth?jwt=eyJhb...&salt=12345...&address=0xabc...`

---

## 3. Application Logic & State Flow

The SPA has two distinct operational phases: **Initiation** and **Callback**.

### Phase A: Initiation (Pre-Login)

1.  **Entry Point Detection:**
    *   On `window.load`, parse `window.location.search`.
    *   Check for `source=obsidian`.
    *   **If missing:** Render standard "Not authorized" or generic landing page.
    *   **If present:** Store the `source` flag in `sessionStorage` (to persist across the OAuth redirect).

2.  **Enoki Client Initialization:**
    *   Initialize `EnokiClient` (using the Public API Key).
    *   *Note: Since EnokiFlow is deprecated, strictly use `EnokiClient` methods for URL generation.*

3.  **Authorization URL Generation:**
    *   Construct the OAuth Authorization URL using the SDK.
    *   **Constraint:** The `redirectUrl` parameter passed to the SDK **must** match the bridge's own HTTPS URL exactly (as whitelisted in the Enoki Portal).

4.  **User Trigger:**
    *   Render a "Log In to Obsidian" button (to prevent browser popup blockers).
    *   *Auto-redirect:* If user interaction guidelines allow, redirect immediately to the generated Provider URL.

### Phase B: Callback (Post-Login)

1.  **Hash Parsing:**
    *   On load, check `window.location.hash` (standard OIDC behavior) for `id_token`.
    *   If present, verify `sessionStorage` contains the `source=obsidian` flag (security check to ensure the flow started here).

2.  **Backend Handshake (The "Salt" Exchange):**
    *   Extract the `id_token` (JWT).
    *   **Critical Step:** Call the Backend endpoint (`POST /api/auth/bridge`) with the JWT.
    *   *Why:* The Frontend is stateless and uses the Public API Key. To securely fetch the persistent user Salt (required for address derivation), it proxies the request to the Backend, which uses the Enoki SDK to retrieve `salt` and `address`.

3.  **Deep Link Construction:**
    *   Compile the `jwt`, `salt`, and `address` into the query string format defined in **Schema 2.2**.
    *   Target Protocol: `obsidian://enoki-auth`.

4.  **Ejection:**
    *   Execute `window.location.href = deepLinkURI`.
    *   **UX Handler:** Display a "Redirecting to Obsidian..." message.
    *   **Fallback:** Provide a manual "Click here if Obsidian didn't open" link (browsers sometimes block custom protocol redirects without explicit user clicks).

---

## 4. Technical Requirements

### 4.1. Environment
*   **Framework:** Framework-agnostic (Vanilla JS, React, or Vue). Recommended: Minimal React or Preact build to minimize load times.
*   **Hosting:** Static hosting provider (GitHub Pages, Vercel, Netlify).
*   **Protocol:** **HTTPS** (Mandatory for OIDC).

### 4.2. Dependencies
*   `@mysten/enoki` (Latest version).
*   `@mysten/sui` (Peer dependency).

### 4.3. Configuration
*   **Public API Key:** Exposed in the frontend build.
*   **Google Client ID:** Exposed in the frontend build.
*   **Callback URL:** Must be hardcoded to the production URL of the Bridge.

---

## 5. Security & Error Handling

### 5.1. Origin Verification
*   The Bridge must only attempt the deep link redirect if it detects the specific intent to log in to Obsidian. This prevents random visitors to the website from triggering the Obsidian protocol handler unexpectedly.

### 5.2. Token Exposure
*   The JWT and Salt are passed via URL parameters in the `obsidian://` protocol.
    *   *Risk:* Local logs on the machine might capture this URI.
    *   *Mitigation:* The JWT is short-lived. This is an accepted trade-off for desktop deep-linking. The Bridge SPA should clear the URL hash (`history.replaceState`) immediately after extraction to prevent the token from lingering in browser history.

### 5.3. Error States
The SPA must handle and display UI for:
*   **Popup Blockers:** If the browser blocks the `obsidian://` redirect.
*   **User Cancellation:** If the user cancels at the Google login screen.
*   **Enoki Downtime:** If the Salt retrieval fails.

---

## 6. Development Checklist

1.  [ ] **Route Handling:** Ensure the router (if using React Router) handles the `id_token` hash correctly, as it appears *after* the query parameters.
2.  [ ] **State Persistence:** Verify `sessionStorage` survives the round-trip to Google and back.
3.  [ ] **Protocol Testing:** Manually test the `obsidian://` link in the browser address bar to ensure the OS prompts to open the app.
4.  [ ] **Clean Up:** Ensure `window.close()` is called (or a "You may close this tab" message is shown) after the handoff.