import type { SuiClient } from '@mysten/sui.js/client';
import type { TransactionBlock } from '@mysten/sui.js/transactions';
import type { ZkLoginSignatureInputs } from '@mysten/sui.js/zklogin';
import type { WritableAtom } from 'nanostores';
import type { Encryption } from './encryption.js';
import type { EnokiClientConfig } from './EnokiClient/index.js';
import { EnokiClient } from './EnokiClient/index.js';
import { EnokiKeypair } from './EnokiKeypair.js';
import type { SyncStore } from './stores.js';
export interface EnokiFlowConfig extends EnokiClientConfig {
    /**
     * The storage interface to persist Enoki data locally.
     * If not provided, it will use a sessionStorage-backed store.
     */
    store?: SyncStore;
    /**
     * The encryption interface that will be used to encrypt data before storing it locally.
     * If not provided, it will use a default encryption interface.
     */
    encryption?: Encryption;
}
export interface ZkLoginState {
    provider?: AuthProvider;
    address?: string;
    salt?: string;
}
export interface ZkLoginSession {
    ephemeralKeyPair: string;
    maxEpoch: number;
    randomness: string;
    expiresAt: number;
    jwt?: string;
    proof?: ZkLoginSignatureInputs;
}
export type AuthProvider = 'google' | 'facebook' | 'twitch';
export declare class EnokiFlow {
    #private;
    $zkLoginSession: WritableAtom<{
        initialized: boolean;
        value: ZkLoginSession | null;
    }>;
    $zkLoginState: WritableAtom<ZkLoginState>;
    constructor(config: EnokiFlowConfig);
    get enokiClient(): EnokiClient;
    createAuthorizationURL(input: {
        provider: AuthProvider;
        clientId: string;
        redirectUrl: string;
        extraParams?: Record<string, unknown>;
    }): Promise<string>;
    handleAuthCallback(hash?: string): Promise<string | null>;
    getSession(): Promise<ZkLoginSession | null>;
    logout(): Promise<void>;
    getProof(): Promise<import("./EnokiClient/type.js").CreateZkLoginZkpApiResponse>;
    getKeypair(): Promise<EnokiKeypair>;
    sponsorTransactionBlock({ network, transactionBlock, client, }: {
        network?: 'mainnet' | 'testnet';
        transactionBlock: TransactionBlock;
        client: SuiClient;
    }): Promise<import("./EnokiClient/type.js").CreateSponsoredTransactionBlockApiResponse>;
    executeTransactionBlock({ bytes, digest, client, }: {
        bytes: string;
        digest: string;
        client: SuiClient;
    }): Promise<{
        digest: string;
    }>;
    sponsorAndExecuteTransactionBlock({ network, transactionBlock, client, }: {
        network?: 'mainnet' | 'testnet';
        transactionBlock: TransactionBlock;
        client: SuiClient;
    }): Promise<{
        digest: string;
    }>;
}
