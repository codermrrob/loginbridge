{
  "version": 3,
  "sources": ["../../src/EnokiFlow.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SuiClient } from '@mysten/sui.js/client';\nimport { decodeSuiPrivateKey } from '@mysten/sui.js/cryptography';\nimport { Ed25519Keypair } from '@mysten/sui.js/keypairs/ed25519';\nimport type { TransactionBlock } from '@mysten/sui.js/transactions';\nimport { fromB64, toB64 } from '@mysten/sui.js/utils';\nimport type { ZkLoginSignatureInputs } from '@mysten/sui.js/zklogin';\nimport { decodeJwt } from 'jose';\nimport type { WritableAtom } from 'nanostores';\nimport { atom, onMount, onSet } from 'nanostores';\n\nimport type { Encryption } from './encryption.js';\nimport { createDefaultEncryption } from './encryption.js';\nimport type { EnokiClientConfig } from './EnokiClient/index.js';\nimport { EnokiClient } from './EnokiClient/index.js';\nimport { EnokiKeypair } from './EnokiKeypair.js';\nimport type { SyncStore } from './stores.js';\nimport { createSessionStorage } from './stores.js';\n\nexport interface EnokiFlowConfig extends EnokiClientConfig {\n\t/**\n\t * The storage interface to persist Enoki data locally.\n\t * If not provided, it will use a sessionStorage-backed store.\n\t */\n\tstore?: SyncStore;\n\t/**\n\t * The encryption interface that will be used to encrypt data before storing it locally.\n\t * If not provided, it will use a default encryption interface.\n\t */\n\tencryption?: Encryption;\n}\n\n// State that is not bound to a session, and is encrypted.\nexport interface ZkLoginState {\n\tprovider?: AuthProvider;\n\taddress?: string;\n\tsalt?: string;\n}\n\n// State that session-bound, and is encrypted in storage.\nexport interface ZkLoginSession {\n\tephemeralKeyPair: string;\n\tmaxEpoch: number;\n\trandomness: string;\n\texpiresAt: number;\n\n\tjwt?: string;\n\tproof?: ZkLoginSignatureInputs;\n}\n\nexport type AuthProvider = 'google' | 'facebook' | 'twitch';\n\nconst createStorageKeys = (apiKey: string) => ({\n\tSTATE: `@enoki/flow/state/${apiKey}`,\n\tSESSION: `@enoki/flow/session/${apiKey}`,\n});\n\nexport class EnokiFlow {\n\t#storageKeys: { STATE: string; SESSION: string };\n\t#enokiClient: EnokiClient;\n\t#encryption: Encryption;\n\t#encryptionKey: string;\n\t#store: SyncStore;\n\n\t$zkLoginSession: WritableAtom<{ initialized: boolean; value: ZkLoginSession | null }>;\n\t$zkLoginState: WritableAtom<ZkLoginState>;\n\n\tconstructor(config: EnokiFlowConfig) {\n\t\tthis.#enokiClient = new EnokiClient({\n\t\t\tapiKey: config.apiKey,\n\t\t\tapiUrl: config.apiUrl,\n\t\t});\n\t\tthis.#encryptionKey = config.apiKey;\n\t\tthis.#encryption = config.encryption ?? createDefaultEncryption();\n\t\tthis.#store = config.store ?? createSessionStorage();\n\t\tthis.#storageKeys = createStorageKeys(config.apiKey);\n\n\t\tlet storedState = null;\n\t\ttry {\n\t\t\tconst rawStoredValue = this.#store.get(this.#storageKeys.STATE);\n\t\t\tif (rawStoredValue) {\n\t\t\t\tstoredState = JSON.parse(rawStoredValue);\n\t\t\t}\n\t\t} catch {\n\t\t\t// Ignore errors\n\t\t}\n\n\t\tthis.$zkLoginState = atom(storedState || {});\n\t\tthis.$zkLoginSession = atom({ initialized: false, value: null });\n\n\t\t// Hydrate the session on mount:\n\t\tonMount(this.$zkLoginSession, () => {\n\t\t\tthis.getSession();\n\t\t});\n\n\t\tonSet(this.$zkLoginState, ({ newValue }) => {\n\t\t\tthis.#store.set(this.#storageKeys.STATE, JSON.stringify(newValue));\n\t\t});\n\t}\n\n\tget enokiClient() {\n\t\treturn this.#enokiClient;\n\t}\n\n\tasync createAuthorizationURL(input: {\n\t\tprovider: AuthProvider;\n\t\tclientId: string;\n\t\tredirectUrl: string;\n\t\textraParams?: Record<string, unknown>;\n\t}) {\n\t\tconst ephemeralKeyPair = new Ed25519Keypair();\n\t\tconst { nonce, randomness, maxEpoch, estimatedExpiration } =\n\t\t\tawait this.#enokiClient.createZkLoginNonce({\n\t\t\t\tephemeralPublicKey: ephemeralKeyPair.getPublicKey(),\n\t\t\t});\n\n\t\tconst params = new URLSearchParams({\n\t\t\t...input.extraParams,\n\t\t\tnonce,\n\t\t\tclient_id: input.clientId,\n\t\t\tredirect_uri: input.redirectUrl,\n\t\t\tresponse_type: 'id_token',\n\t\t\t// TODO: Eventually fetch the scopes for this client ID from the Enoki service:\n\t\t\tscope: [\n\t\t\t\t'openid',\n\t\t\t\t// Merge the requested scopes in with the required openid scopes:\n\t\t\t\t...(input.extraParams && 'scope' in input.extraParams\n\t\t\t\t\t? (input.extraParams.scope as string[])\n\t\t\t\t\t: []),\n\t\t\t]\n\t\t\t\t.filter(Boolean)\n\t\t\t\t.join(' '),\n\t\t});\n\n\t\tlet oauthUrl: string;\n\t\tswitch (input.provider) {\n\t\t\tcase 'google': {\n\t\t\t\toauthUrl = `https://accounts.google.com/o/oauth2/v2/auth?${params}`;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase 'facebook': {\n\t\t\t\toauthUrl = `https://www.facebook.com/v17.0/dialog/oauth?${params}`;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase 'twitch': {\n\t\t\t\tparams.set('force_verify', 'true');\n\t\t\t\toauthUrl = `https://id.twitch.tv/oauth2/authorize?${params}`;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Invalid provider: ${input.provider}`);\n\t\t}\n\n\t\tthis.$zkLoginState.set({ provider: input.provider });\n\t\tawait this.#setSession({\n\t\t\texpiresAt: estimatedExpiration,\n\t\t\tmaxEpoch,\n\t\t\trandomness,\n\t\t\tephemeralKeyPair: toB64(decodeSuiPrivateKey(ephemeralKeyPair.getSecretKey()).secretKey),\n\t\t});\n\n\t\treturn oauthUrl;\n\t}\n\n\t// TODO: Should our SDK manage this automatically in addition to exposing a method?\n\tasync handleAuthCallback(hash: string = window.location.hash) {\n\t\tconst params = new URLSearchParams(hash.startsWith('#') ? hash.slice(1) : hash);\n\n\t\t// Before we handle the auth redirect and get the state, we need to restore it:\n\t\tconst zkp = await this.getSession();\n\n\t\tif (!zkp || !zkp.ephemeralKeyPair || !zkp.maxEpoch || !zkp.randomness) {\n\t\t\tthrow new Error(\n\t\t\t\t'Start of sign-in flow could not be found. Ensure you have started the sign-in flow before calling this.',\n\t\t\t);\n\t\t}\n\n\t\tconst jwt = params.get('id_token');\n\t\tif (!jwt) {\n\t\t\tthrow new Error('Missing ID Token');\n\t\t}\n\n\t\tconst decodedJwt = decodeJwt(jwt);\n\t\tif (!decodedJwt.sub || !decodedJwt.aud || typeof decodedJwt.aud !== 'string') {\n\t\t\tthrow new Error('Missing JWT data');\n\t\t}\n\n\t\tconst { address, salt } = await this.#enokiClient.getZkLogin({ jwt });\n\n\t\tthis.$zkLoginState.set({\n\t\t\t...this.$zkLoginState.get(),\n\t\t\tsalt,\n\t\t\taddress,\n\t\t});\n\t\tawait this.#setSession({\n\t\t\t...zkp,\n\t\t\tjwt,\n\t\t});\n\n\t\treturn params.get('state');\n\t}\n\n\tasync #setSession(newValue: ZkLoginSession | null) {\n\t\tif (newValue) {\n\t\t\tconst storedValue = await this.#encryption.encrypt(\n\t\t\t\tthis.#encryptionKey,\n\t\t\t\tJSON.stringify(newValue),\n\t\t\t);\n\n\t\t\tthis.#store.set(this.#storageKeys.SESSION, storedValue);\n\t\t} else {\n\t\t\tthis.#store.delete(this.#storageKeys.SESSION);\n\t\t}\n\n\t\tthis.$zkLoginSession.set({ initialized: true, value: newValue });\n\t}\n\n\tasync getSession() {\n\t\tif (this.$zkLoginSession.get().initialized) {\n\t\t\treturn this.$zkLoginSession.get().value;\n\t\t}\n\n\t\ttry {\n\t\t\tconst storedValue = this.#store.get(this.#storageKeys.SESSION);\n\t\t\tif (!storedValue) return null;\n\n\t\t\tconst state: ZkLoginSession = JSON.parse(\n\t\t\t\tawait this.#encryption.decrypt(this.#encryptionKey, storedValue),\n\t\t\t);\n\n\t\t\t// TODO: Rather than having expiration act as a logout, we should keep the state that still is relevant,\n\t\t\t// and just clear out the expired session, but keep the other zkLogin state.\n\t\t\tif (state?.expiresAt && Date.now() > state.expiresAt) {\n\t\t\t\tawait this.logout();\n\t\t\t} else {\n\t\t\t\tthis.$zkLoginSession.set({ initialized: true, value: state });\n\t\t\t}\n\t\t} catch {\n\t\t\tthis.$zkLoginSession.set({ initialized: true, value: null });\n\t\t}\n\n\t\treturn this.$zkLoginSession.get().value;\n\t}\n\n\tasync logout() {\n\t\tthis.$zkLoginState.set({});\n\t\tthis.#store.delete(this.#storageKeys.STATE);\n\n\t\tawait this.#setSession(null);\n\t}\n\n\t// TODO: Should this return the proof if it already exists?\n\tasync getProof() {\n\t\tconst zkp = await this.getSession();\n\t\tconst { salt } = this.$zkLoginState.get();\n\n\t\tif (zkp?.proof) {\n\t\t\tif (zkp.expiresAt && Date.now() > zkp.expiresAt) {\n\t\t\t\tthrow new Error('Stored proof is expired.');\n\t\t\t}\n\n\t\t\treturn zkp.proof;\n\t\t}\n\n\t\tif (!salt || !zkp || !zkp.jwt) {\n\t\t\tthrow new Error('Missing required parameters for proof generation');\n\t\t}\n\n\t\tconst ephemeralKeyPair = Ed25519Keypair.fromSecretKey(fromB64(zkp.ephemeralKeyPair));\n\n\t\tconst proof = await this.#enokiClient.createZkLoginZkp({\n\t\t\tjwt: zkp.jwt,\n\t\t\tmaxEpoch: zkp.maxEpoch,\n\t\t\trandomness: zkp.randomness,\n\t\t\tephemeralPublicKey: ephemeralKeyPair.getPublicKey(),\n\t\t});\n\n\t\tawait this.#setSession({\n\t\t\t...zkp,\n\t\t\tproof,\n\t\t});\n\n\t\treturn proof;\n\t}\n\n\tasync getKeypair() {\n\t\t// Get the proof, so that we ensure it exists in state:\n\t\tawait this.getProof();\n\n\t\tconst zkp = await this.getSession();\n\n\t\t// Check to see if we have the essentials for a keypair:\n\t\tconst { address } = this.$zkLoginState.get();\n\t\tif (!address || !zkp || !zkp.proof) {\n\t\t\tthrow new Error('Missing required data for keypair generation.');\n\t\t}\n\n\t\tif (Date.now() > zkp.expiresAt) {\n\t\t\tthrow new Error('Stored proof is expired.');\n\t\t}\n\n\t\treturn new EnokiKeypair({\n\t\t\taddress,\n\t\t\tmaxEpoch: zkp.maxEpoch,\n\t\t\tproof: zkp.proof,\n\t\t\tephemeralKeypair: Ed25519Keypair.fromSecretKey(fromB64(zkp.ephemeralKeyPair)),\n\t\t});\n\t}\n\n\tasync sponsorTransactionBlock({\n\t\tnetwork,\n\t\ttransactionBlock,\n\t\tclient,\n\t}: {\n\t\tnetwork?: 'mainnet' | 'testnet';\n\t\ttransactionBlock: TransactionBlock;\n\t\tclient: SuiClient;\n\t}) {\n\t\tconst session = await this.getSession();\n\n\t\tif (!session || !session.jwt) {\n\t\t\tthrow new Error('Missing required data for sponsorship.');\n\t\t}\n\n\t\tconst transactionBlockKindBytes = await transactionBlock.build({\n\t\t\tonlyTransactionKind: true,\n\t\t\tclient,\n\t\t\t// Theses limits will get verified during the final transaction construction, so we can safely ignore them here:\n\t\t\tlimits: {\n\t\t\t\tmaxGasObjects: Infinity,\n\t\t\t\tmaxPureArgumentSize: Infinity,\n\t\t\t\tmaxTxGas: Infinity,\n\t\t\t\tmaxTxSizeBytes: Infinity,\n\t\t\t},\n\t\t});\n\n\t\treturn await this.#enokiClient.createSponsoredTransactionBlock({\n\t\t\tjwt: session.jwt,\n\t\t\tnetwork,\n\t\t\ttransactionBlockKindBytes: toB64(transactionBlockKindBytes),\n\t\t});\n\t}\n\n\tasync executeTransactionBlock({\n\t\tbytes,\n\t\tdigest,\n\t\tclient,\n\t}: {\n\t\tbytes: string;\n\t\tdigest: string;\n\t\tclient: SuiClient;\n\t}) {\n\t\tconst keypair = await this.getKeypair();\n\t\tconst userSignature = await keypair.signTransactionBlock(fromB64(bytes));\n\n\t\tawait this.#enokiClient.executeSponsoredTransactionBlock({\n\t\t\tdigest,\n\t\t\tsignature: userSignature.signature,\n\t\t});\n\n\t\t// TODO: Should the parent just do this?\n\t\tawait client.waitForTransactionBlock({ digest });\n\n\t\treturn { digest };\n\t}\n\n\tasync sponsorAndExecuteTransactionBlock({\n\t\tnetwork,\n\t\ttransactionBlock,\n\t\tclient,\n\t}: {\n\t\tnetwork?: 'mainnet' | 'testnet';\n\t\ttransactionBlock: TransactionBlock;\n\t\tclient: SuiClient;\n\t}) {\n\t\tconst { bytes, digest } = await this.sponsorTransactionBlock({\n\t\t\tnetwork,\n\t\t\ttransactionBlock,\n\t\t\tclient,\n\t\t});\n\t\treturn await this.executeTransactionBlock({ bytes, digest, client });\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
